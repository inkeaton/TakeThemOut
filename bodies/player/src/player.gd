class_name Player
extends CharacterBody2D

#//////////////////////////////////////////////////////////////////////////////#

@export_category("Physics") #//////////////////////////////////////////////////#
## Base Movement Speed
@export var DEFAULT_SPEED: float = 50.0

## Movement factor, use to modify speed
var speed_factor: float = 1.0 :
	set(new_factor):
		speed_factor = new_factor
		speed = DEFAULT_SPEED * speed_factor

## Current speed
@onready var speed: float = DEFAULT_SPEED * speed_factor

## Weight of the object, used for knockback
@export var DEFAULT_WEIGHT: float = 100

## Weight factor, use to modify weight
var weight_factor: float = 1.0:
	set(new_factor):
		weight_factor = new_factor
		weight = DEFAULT_WEIGHT * weight_factor

## Current Weight
@onready var weight: float = DEFAULT_WEIGHT * weight_factor

## How much the floor slows us down
var resistance: float = 1.0:
	set(new_resistance):
		resistance = clampf(new_resistance, 0, INF)

## How much we slide on the floor
var friction: float = 100:
	get():
		return friction * speed/100

# Used ofr determing movemnt directions
const SECTOR_ANGLE := TAU / 8

## Last pressed direction
var last_dpad_direction: Vector2 = Vector2.ZERO

# --- BREADCRUMBS SYSTEM ---
@export_category("Breadcrumbs")
@export var crumb_scene : PackedScene 
@export var crumb_spacing: float = 30.0 
@export var max_crumbs_in_world : int = 50

var crumb_container : Node = null 
var last_crumb_pos: Vector2 = Vector2.ZERO

func _ready() -> void:
	$AnimationTree/AnimationPlayer.current_animation = "walk_down"
	
	# FIX: Defer the crumb setup to the next frame to avoid "Parent is busy" error
	call_deferred("_setup_crumb_container")

func _setup_crumb_container() -> void:
	# This runs one frame later, when the Scene Tree is unlocked
	var scene_root = get_tree().current_scene
	
	if not scene_root.has_node("Crumbs"):
		crumb_container = Node2D.new()
		crumb_container.name = "Crumbs"
		scene_root.add_child(crumb_container)
	else:
		crumb_container = scene_root.get_node("Crumbs")
	
	# Now that container exists, drop the first crumb
	drop_crumb()

func _physics_process(_delta: float) -> void:
	compute_movement()
	move_and_slide()
	
	if global_position.distance_to(last_crumb_pos) >= crumb_spacing:
		drop_crumb()

func drop_crumb() -> void:
	# Safety Check: If setup isn't finished or scene is missing, abort
	if not crumb_scene or not crumb_container: 
		return
	
	last_crumb_pos = global_position
	
	# Instantiate Node
	var new_crumb = crumb_scene.instantiate()
	new_crumb.global_position = global_position
	new_crumb.add_to_group("crumb")  # Singular to match patrol detection
	crumb_container.add_child(new_crumb)

#//////////////////////////////////////////////////////////////////////////////#

func die() -> void:
	Messages.print_message("I'm dead :(", name)
	self.queue_free()

func compute_animations(dpad_direction: Vector2 = Vector2.ZERO) -> void:
	var anim_string: String = "idle"
	
	if dpad_direction != Vector2.ZERO:
		var ang = dpad_direction.angle()
		if ang < 0:
			ang += TAU
	
		match int(floor((ang + SECTOR_ANGLE * 0.5) / SECTOR_ANGLE)):
			0, 1, 2: # Right / East
				anim_string = "walk"
				$Sprite.flip_h = false
			3, 4, 5: # Left / West (Mirrored)
				anim_string = "walk"
				$Sprite.flip_h = true
			6, 7: # Up (if you had specific side-up animations)
				anim_string = "walk_up"
				$Sprite.flip_h = false

## Compute movement generated by user input
func compute_input_movement() -> Vector2:
	var dpad_direction = Input.get_vector("left", "right", "up", "down")
	compute_animations(dpad_direction)
	
	if dpad_direction != Vector2.ZERO and dpad_direction != last_dpad_direction:
		last_dpad_direction = dpad_direction
		
	return dpad_direction * speed

## Compute actual movement
func compute_movement():
	var input_velocity = compute_input_movement() 
	var abstract_velocity = input_velocity
	velocity = velocity.move_toward(abstract_velocity / resistance, friction)
