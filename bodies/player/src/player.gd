class_name Player
extends CharacterBody2D

#//////////////////////////////////////////////////////////////////////////////#

@export_category("Physics") #//////////////////////////////////////////////////#
## Base Movement Speed
@export var DEFAULT_SPEED: float = 50.0

## Movement factor, use to modify speed
var speed_factor: float = 1.0 :
	set(new_factor):
		speed_factor = new_factor
		speed = DEFAULT_SPEED * speed_factor

## Current speed
@onready var speed: float = DEFAULT_SPEED * speed_factor

## Weight of the object, used for knockback
@export var DEFAULT_WEIGHT: float = 100

## Weight factor, use to modify weight
var weight_factor: float = 1.0:
	set(new_factor):
		weight_factor = new_factor
		weight = DEFAULT_WEIGHT * weight_factor

## Current Weight
@onready var weight: float = DEFAULT_WEIGHT * weight_factor

## How much the floor slows us down
var resistance: float = 1.0:
	set(new_resistance):
		resistance = clampf(new_resistance, 0, INF)

## How much we slide on the floor
var friction: float = 100:
	get():
		return friction * speed/100

# Used ofr determing movemnt directions
const SECTOR_ANGLE := TAU / 8

## Last pressed direction
var last_dpad_direction: Vector2 = Vector2.ZERO

#//////////////////////////////////////////////////////////////////////////////#

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	$AnimationTree/AnimationPlayer.current_animation = "walk_down"
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	pass


func _physics_process(_delta: float) -> void:
	compute_movement()
	move_and_slide()

func die() -> void:
	Messages.print_message("I'm dead :(", name)
	self.queue_free()

func compute_animations(dpad_direction: Vector2 = Vector2.ZERO) -> void:
	## TBD use actual animations, learn about animaion trees
	var anim_string: String
	anim_string = "idle"
	
	if dpad_direction != Vector2.ZERO:
		var ang = dpad_direction.angle()
		if ang < 0:
			ang += TAU
	
		match int(floor((ang + SECTOR_ANGLE * 0.5) / SECTOR_ANGLE)):
			0: #est
				anim_string = "walk"
				$Sprite.flip_h = false
			1:
				anim_string = "walk"
				$Sprite.flip_h = false
			2:
				anim_string = "walk"
			3:
				anim_string = "walk"
				$Sprite.flip_h = true
			4:
				anim_string = "walk"
				$Sprite.flip_h = true
			5:
				anim_string = "walk_up"
				$Sprite.flip_h = true
			6:
				anim_string = "walk_up"
			7:
				anim_string = "walk_up"
				$Sprite.flip_h = false

## Compute movement generated by user input
func compute_input_movement() -> Vector2:
	# Get dpad movement
	var dpad_direction = Input.get_vector("left", "right", "up", "down")
	## TBD: find a better place to call this
	# Set animations accordingly
	compute_animations(dpad_direction)
	# Save if changed from before
	if dpad_direction != Vector2.ZERO and dpad_direction != last_dpad_direction:
		last_dpad_direction = dpad_direction
	# Compute intended movement
	var dpad_velocity = dpad_direction * speed
	# Return final result
	return dpad_velocity

## Compute actual movement
func compute_movement():
	var input_velocity 		= compute_input_movement() 
	# Put all together
	var abstract_velocity = input_velocity
	# Apply physics
	velocity = velocity.move_toward(abstract_velocity / resistance, friction)
