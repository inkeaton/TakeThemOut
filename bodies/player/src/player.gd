class_name Player
extends CharacterBody2D

#//////////////////////////////////////////////////////////////////////////////#

@export_category("Physics") #//////////////////////////////////////////////////#
## Base Movement Speed
@export var DEFAULT_SPEED: float = 50.0

## Movement factor, use to modify speed
var speed_factor: float = 1.0 :
	set(new_factor):
		speed_factor = new_factor
		speed = DEFAULT_SPEED * speed_factor

## Current speed
@onready var speed: float = DEFAULT_SPEED * speed_factor

## Weight of the object, used for knockback
@export var DEFAULT_WEIGHT: float = 100

## Weight factor, use to modify weight
var weight_factor: float = 1.0:
	set(new_factor):
		weight_factor = new_factor
		weight = DEFAULT_WEIGHT * weight_factor

## Current Weight
@onready var weight: float = DEFAULT_WEIGHT * weight_factor

## How much the floor slows us down
var resistance: float = 1.0:
	set(new_resistance):
		resistance = clampf(new_resistance, 0, INF)

## How much we slide on the floor
var friction: float = 100:
	get():
		return friction * speed/100

# Used ofr determing movemnt directions
const SECTOR_ANGLE := TAU / 8

## Last pressed direction
var last_dpad_direction: Vector2 = Vector2.ZERO

# --- BREADCRUMBS SYSTEM ---
@export_category("Breadcrumbs")
## How many pixels to move before dropping a new crumb
@export var crumb_spacing: float = 30.0 
## Maximum number of crumbs to keep in memory (history length)
@export var max_crumbs: int = 50
## Toggle to visualize crumbs in game
@export var debug_crumbs: bool = false

# Array of Vector2 positions (0 = oldest, -1 = newest)
var breadcrumbs: Array[Vector2] = []
var last_crumb_pos: Vector2 = Vector2.ZERO

#//////////////////////////////////////////////////////////////////////////////#

func _ready() -> void:
	$AnimationTree/AnimationPlayer.current_animation = "walk_down"
	# Initialize first crumb at start position
	drop_crumb()

func _physics_process(_delta: float) -> void:
	compute_movement()
	move_and_slide()
	
	# Check if we moved far enough to drop a crumb
	if global_position.distance_to(last_crumb_pos) >= crumb_spacing:
		drop_crumb()
	
	# Redraw debug lines if enabled
	if debug_crumbs:
		queue_redraw()

func drop_crumb() -> void:
	last_crumb_pos = global_position
	breadcrumbs.push_back(last_crumb_pos)
	
	# Maintain the size limit
	if breadcrumbs.size() > max_crumbs:
		breadcrumbs.pop_front() # Remove oldest

# Draw the path for debugging
func _draw() -> void:
	if debug_crumbs and breadcrumbs.size() > 1:
		for i in range(breadcrumbs.size() - 1):
			# Draw line from crumb i to i+1
			# We must use to_local because draw_line expects local coordinates
			var start = to_local(breadcrumbs[i])
			var end = to_local(breadcrumbs[i+1])
			draw_line(start, end, Color(((i+1)*0.2), 0, 0, 0.5), 20.0)

#//////////////////////////////////////////////////////////////////////////////#

func die() -> void:
	Messages.print_message("I'm dead :(", name)
	self.queue_free()

func compute_animations(dpad_direction: Vector2 = Vector2.ZERO) -> void:
	var anim_string: String = "idle"
	
	if dpad_direction != Vector2.ZERO:
		var ang = dpad_direction.angle()
		if ang < 0:
			ang += TAU
	
		match int(floor((ang + SECTOR_ANGLE * 0.5) / SECTOR_ANGLE)):
			0, 1, 2: # Right / East
				anim_string = "walk"
				$Sprite.flip_h = false
			3, 4, 5: # Left / West (Mirrored)
				anim_string = "walk"
				$Sprite.flip_h = true
			6, 7: # Up (if you had specific side-up animations)
				anim_string = "walk_up"
				$Sprite.flip_h = false

## Compute movement generated by user input
func compute_input_movement() -> Vector2:
	var dpad_direction = Input.get_vector("left", "right", "up", "down")
	compute_animations(dpad_direction)
	
	if dpad_direction != Vector2.ZERO and dpad_direction != last_dpad_direction:
		last_dpad_direction = dpad_direction
		
	return dpad_direction * speed

## Compute actual movement
func compute_movement():
	var input_velocity = compute_input_movement() 
	var abstract_velocity = input_velocity
	velocity = velocity.move_toward(abstract_velocity / resistance, friction)
