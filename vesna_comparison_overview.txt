# Comparison: vesna-temper vs vesna-light-main

## Key Differences

### 1. **Agent Configuration Method**

**vesna-light-main** uses beliefs for configuration:
```asl
agent alice:alice.asl {
    beliefs:    address( localhost )
                port( 9081 )
    ag-class:   vesna.VesnaAgent
}
```

**vesna-temper** uses user parameters:
```jcm
agent alice:alice.asl {
    ag-class:   vesna.VesnaAgent
    temper:     temper( prop1(0.2), prop2(0.3), prop3(-0.5)[mood], prop4(0.3)[mood] )
    address:    localhost
    port:       9080
    strategy:   most_similar
}
```

### 2. **Temper System (New in vesna-temper)**

The Temper class is entirely new and provides:

- **Personality**: Persistent traits (values 0-1)
- **Mood**: Mutable traits (values -1 to 1), marked with [mood] annotation
- **Decision Strategies**:
  - `most_similar`: Deterministic, chooses plans closest to current temper
  - `random`: Weighted random selection based on similarity

### 3. **Plan Selection Override**

VesnaAgent in vesna-temper overrides:

| Method | Purpose |
|--------|---------|
| selectOption() | Chooses between applicable plans based on temper |
| selectIntention() | Prioritizes intentions based on temper |

Plans can have temper annotations:
```asl
@p1[temper( [ prop1( 0.0 ), prop2( 0.3 ) ] ), effects( [ prop3( 0.7 ), prop4( -0.05 ) ] ) ]
+!p
    <-  .print( "ciao" ).
```

### 4. **New Wrapper Classes**

- OptionWrapper - Wraps Option for temper selection
- IntentionWrapper - Wraps Intention for temper selection
- TemperSelectable - Interface for temper-based selection

### 5. **WebSocket Handler Method Naming**

| vesna-light-main | vesna-temper |
|------------------|--------------|
| handle_msg() | handleMsg() |
| handle_error() | handleError() |

---

## Integrating vesna-temper with Godot

### 1. **Set Up the Godot Body**

Based on the vesna-light-main example, each agent needs a body in Godot that:

- Implements a WebSocket server on a specific port
- Handles actions: vesna.walk(), vesna.rotate(), vesna.jump()
- Sends perceptions back to the mind

### 2. **Configure the JaCaMo Agent**

In your vesna.jcm file:

```jcm
agent my_agent:my_agent.asl {
    ag-class:   vesna.VesnaAgent
    address:    localhost
    port:       9080          // Must match Godot WebSocket server port
    temper:     temper( trait1(0.5), trait2(0.3), mood_trait(-0.2)[mood] )
    strategy:   random        // or most_similar
    goals:      start
}
```

### 3. **Create Agent Plans with Temper**

In your .asl file:

```asl
// Include vesna actions
{ include("vesna.asl") }

// Define plans with temper annotations
@aggressive[temper( [ aggression( 0.8 ) ] ), effects( [ stress( 0.1 ) ] )]
+!react_to_threat
    <-  vesna.walk( enemy );
        !attack.

@defensive[temper( [ aggression( 0.2 ) ] ), effects( [ stress( -0.1 ) ] )]
+!react_to_threat
    <-  vesna.walk( cover );
        !hide.
```

### 4. **Run Both Systems**

1. Start Godot project with WebSocket servers running
2. Run JaCaMo: gradle run in the vesna-temper directory
3. Agents connect via WebSocket and synchronize actions/perceptions

### 5. **Communication Protocol**

Messages follow this JSON structure:

```json
{
    "sender": "agent_name",
    "receiver": "body_name", 
    "type": "signal",
    "data": { ... }
}
```

---

## Project Structure Overview

```
vesna-temper/
├── vesna.jcm              # JaCaMo project configuration
├── build.gradle           # Gradle build configuration
├── src/
│   ├── agt/               # Agent source files
│   │   ├── alice.asl      # Example agent definition
│   │   ├── vesna.asl      # Shared agent library
│   │   └── vesna/         # Java agent classes
│   │       ├── VesnaAgent.java
│   │       ├── Temper.java
│   │       ├── TemperSelectable.java
│   │       ├── OptionWrapper.java
│   │       ├── IntentionWrapper.java
│   │       ├── WsClient.java
│   │       ├── WsClientMsgHandler.java
│   │       └── via/       # Vesna Internal Actions
│   │           ├── walk.java
│   │           ├── rotate.java
│   │           └── jump.java
│   └── env/               # Environment artifacts
│       ├── playgrounds/office/
│       │   ├── CoffeeMachine.java
│       │   └── Cup.java
│       └── vesna/
│           ├── SituatedArtifact.java
│           └── GrabbableArtifact.java
```

---

## How to Use vesna-temper

### Step 1: Define Your Agent Configuration

In vesna.jcm:

```jcm
mas my_game {

    agent guard:guard.asl {
        ag-class:   vesna.VesnaAgent
        temper:     temper( 
                        aggression(0.7), 
                        patience(0.3), 
                        fear(0.2)[mood], 
                        alertness(0.5)[mood] 
                    )
        address:    localhost
        port:       9080
        strategy:   random
        goals:      patrol
    }

    agent civilian:civilian.asl {
        ag-class:   vesna.VesnaAgent
        temper:     temper( 
                        aggression(0.1), 
                        patience(0.8), 
                        fear(0.0)[mood], 
                        alertness(0.3)[mood] 
                    )
        address:    localhost
        port:       9081
        strategy:   most_similar
        goals:      wander
    }

}
```

### Step 2: Create Agent Behavior Files

```asl
{ include("vesna.asl") }

// Personality-matched plans for patrolling
@aggressive_patrol[temper([aggression(0.8), alertness(0.7)]), effects([fear(-0.1)])]
+!patrol
    <-  .print("Aggressive patrol mode");
        vesna.via.walk(checkpoint_a);
        vesna.via.walk(checkpoint_b);
        !patrol.

@cautious_patrol[temper([aggression(0.2), alertness(0.9)]), effects([alertness(0.1)])]
+!patrol
    <-  .print("Cautious patrol mode");
        vesna.via.rotate(360);  // Look around first
        vesna.via.walk(checkpoint_a);
        !patrol.

// React to threats based on mood
@fight[temper([aggression(0.7), fear(0.0)]), effects([fear(0.2), alertness(0.3)])]
+threat(Enemy)
    <-  .print("Engaging threat!");
        vesna.via.walk(Enemy);
        !attack(Enemy).

@flee[temper([aggression(0.2), fear(0.8)]), effects([fear(-0.1)])]
+threat(Enemy)
    <-  .print("Retreating!");
        vesna.via.walk(safe_zone).
```

### Step 3: Set Up Godot WebSocket Server

In Godot, create a body script:

```gdscript
extends CharacterBody3D

var ws_server := WebSocketServer.new()
var peer: WebSocketPeer = null

@export var port: int = 9080

func _ready():
    ws_server.listen(port)
    print("WebSocket server listening on port ", port)

func _process(delta):
    ws_server.poll()
    
    if ws_server.get_connection_status() == WebSocketServer.CONNECTION_CONNECTED:
        if peer == null:
            peer = ws_server.get_peer(1)
        
        while peer.get_available_packet_count() > 0:
            var msg = peer.get_packet().get_string_from_utf8()
            handle_message(JSON.parse_string(msg))

func handle_message(data: Dictionary):
    match data.get("type"):
        "action":
            execute_action(data.get("action"), data.get("params", {}))

func execute_action(action: String, params: Dictionary):
    match action:
        "walk":
            var target = get_node(params.get("target"))
            await walk_to(target.global_position)
            send_action_complete(action)
        "rotate":
            var angle = params.get("angle", 0)
            await rotate_by(angle)
            send_action_complete(action)
        "jump":
            velocity.y = jump_speed
            send_action_complete(action)

func send_action_complete(action: String):
    var msg = {
        "type": "action_result",
        "action": action,
        "success": true
    }
    peer.put_packet(JSON.stringify(msg).to_utf8_buffer())

func send_perception(belief: String, value):
    var msg = {
        "type": "perception",
        "data": {
            "belief": belief,
            "value": value
        }
    }
    peer.put_packet(JSON.stringify(msg).to_utf8_buffer())
```

### Step 4: Build and Run

```bash
# In vesna-temper directory
./gradlew build
./gradlew run
```

---

## Selection Strategies Explained

### `most_similar` (Deterministic)

Selects the plan whose temper annotation is closest to the agent's current temper state:

```
Agent Temper: aggression(0.7), fear(0.3)

Plan A [temper([aggression(0.8), fear(0.2)])] → similarity = 0.9
Plan B [temper([aggression(0.2), fear(0.8)])] → similarity = 0.5

Selected: Plan A (highest similarity)
```

### `random` (Probabilistic)

Uses similarity as weights for random selection:

```
Agent Temper: aggression(0.5), fear(0.5)

Plan A [temper([aggression(0.8)])] → weight = 0.7
Plan B [temper([aggression(0.3)])] → weight = 0.8
Plan C [temper([aggression(0.5)])] → weight = 1.0

Selection probability:
- Plan A: 28%
- Plan B: 32%
- Plan C: 40%
```

---

## Summary

| Component | Purpose |
|-----------|---------|
| VesnaAgent | Main agent class with temper-based selection |
| Temper | Manages personality traits and moods |
| OptionWrapper | Extracts temper from plan options |
| IntentionWrapper | Extracts temper from active intentions |
| WsClient | WebSocket communication with Godot |
| Internal Actions | walk, rotate, jump commands to Godot |
| Artifacts | CArtAgO artifacts for environment objects |
